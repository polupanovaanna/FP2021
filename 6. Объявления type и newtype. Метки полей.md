# Объявления type и newtype. Метки полей.

#### Type
Мотивация: в Haskell очень часто само имя или конструктор типа ялвяется очень большим, поэтому удобно для такого типа задавать более короткий, используя ключевое слово `type` (то есть *синоним типа*).
В стандартной библиотеке используется как минимум такая обертка:
```haskell
type String = [Char]
```
Синонимы типа могут быть параметризованными:
```bash
GHCi> type EC = Either Char
GHCi> :kind EC
EC :: * -> *
```

Синонимы типов вводятся исключительно для удобства и играют чисто синтаксическую роль. Они позволяют заменять громоздкие типовые конструкции на компактные,
скрывая ненужные детали. Синоним и исходный тип полностью взаимозаменяемы
```bash
GHCi> str = "Hello" :: String
GHCi> :t str
str :: String
GHCi> length str
5
```
Все классы типов и интерфейсы при использовании синонимов типов сохраняются. Например, можем пользоваться самим типом и синонимом типа вперемешку:
```bash
GHCi> let xs = ['a', 'b', 'c'] :: String
GHCi> let ys = ['a', 'b', 'c'] :: [Char]
GHCi> xs == ys
True
```
Пример с ассоциативным списком:
```haskell
type AssocList k v = [(k, v)]
```

#### Newtype
Ключевое слово newtype задаёт новый тип c единственным однопараметрическим конструктором, упаковывающий уже существующий тип (то есть `newtype` - это обертка над суещсвтующим типом с единственным конструктором):
```haskell
newtype AgeNT = AgeNT Int
```
Однако отличие `newtype` от type заключается в том, что упаковка в `newtype` приводит к тому, что все представители, которые имеются у упаковываемого типа, пропадают (таким образом можем реализовать разные интерфейсы для типа и его оберток). 
Однако эта проблема исправима - нужно просто добавить `deriving ...` в объявление `newtype`


Общий синтаксис объявления `newtype` таков
```
newtype T u1 ... uk = N t
```
Здесь, `ui` — метапеременные типа, `t` — упаковываемый тип данных, зависящий от `ui`. Конструкторам типа `T` и данных `N` обычно дают одно и то же имя. В подавляющем большинстве случаев объявление newtype сопровождается меткой для единственного поля. То есть наш пример удобно переписать так
```haskell
newtype AgeNT = AgeNT { getAgeNT :: Int }
```
В отличие от объявления синонима `type` переименование `newtyp`e действительно порождает новый тип данных, хотя внутри него лежит уже существующий тип. Приведение от внутреннего типа к упаковывающему всегда должно выполняться явно, для этого служит конструктор данных упаковывающего типа. Приведение в обратную сторону тоже легко обеспечить: если есть метка поля, то она выполняет эту работу; если ее нет, то можно воспользоваться сопоставлением с образцом.
```bash
GHCi> age = AgeNT 42
GHCi> :t age
age :: AgeNT
GHCi> age
AgeNT {getAgeNT = 42}
GHCi> getAgeNT age
42
```

Может показаться, что особого смысла во введении типа данных с помощью `newtype` нет. Ровно того же поведения мы могли бы добиться, объявив аналогичный тип данных с помощью `data`
```haskell
data AgeDT = AgeDT { getAgeDT :: Int }
```

На самом деле, различий между `data` и `newtype` два:
1. Тип, определенный с помощью `newtype`, гарантированно имеет один конструктор с одним параметром. Так как конструктор один, во время исполнения программы он не нужен. Если мы определяем `data`, то конструктор нужен, даже если он один, для сопоставления с образцом.
2. Тип данных, определенный с помощью `newtype` более ленив, чем с `data`.

Тем не менее между `AgeNT` и `AgeDT` есть важное операционное отличие. Тип данных `AgeDT` задает дополнительный уровень косвенности во время исполнения, в то время как `AgeNT` во время исполнения — это просто `Int`. Это приводит к большей эффективности и лучшей определенности `newtype`. Действительно, реализовав похожие функции
```haskell
ignoreNT (AgeNT n) = 42
ignoreDT (AgeDT n) = 42
```
можно обнаружить следующую разницу в поведении
```bash
GHCi> ignoreNT undefined
42
GHCi> ignoreDT undefined
*** Exception: Prelude.undefined
```
Функция `ignoreDT` расходится из-за попытки сопоставить во время исполнения расходимость с образцом (`AgeDT n`). В противоположность этому у функции `ignoreNT` образец (`AgeNT n`) в аргументе существует только статически. Во время исполнения аргумент `ignoreNT` — это переменная `n` типа `Int`, поэтому необходимость форсировать вычисление `undefined` отсутствует.
Приведем несколько простых примеров упаковок newtype из стандартной библиотеки:
```haskell
newtype All = All { getAll :: Bool }
newtype Any = Any { getAny :: Bool }
newtype Sum a = Sum { getSum :: a }
newtype Product a = Product { getProduct :: a }
newtype Identity a = Identity { runIdentity :: a }
newtype Endo a = Endo { appEndo :: a -> a }
```
Типы `All` и `Any` упаковывают булев тип для реализации представителя класса типов
Monoid относительно конъюнкции и дизъюнкции соответственно. Типы `Sum` и `Product` нужны для тех же целей, но не для булева типа, а для числовых типов. Они позволяют наделить числа интерфейсом моноида относительно сложения и умножения. Тип `Identity` — это универсальная упаковка для произвольного типа, а `Endo` — универсальная упаковка для произвольного эндоморфизма. Отметим, что `Sum`, `Product` и `Identity` структурно совершенно идентичны, но используются для разных целей.

#### Метки полей
Для доступа к полям типа-произведения, например
```haskell
data Point a = Pt a a
  deriving Show
```
приходится использовать сопоставление с образцом напрямую, или упаковывая такое сопоставление в специальные лямбды 
`\(Pt x _) -> x` или `\(Pt _ y) -> y`.
Можно было бы вместо анонимных лямбд явно определить именованные функции доступа
```haskell
ptx :: Point a -> a
ptx (Pt x _) = x
pty :: Point a -> a
pty (Pt _ y) = y
```
Для сложных типов с большим количеством полей это утомительная, хотя и несложная работа. Однако в Haskell есть возможность получить ровно ту же функциональность
(и даже большую!), просто задав имена для полей типа-произведения. Это делается с помощью механизма меток полей (`field labels`) при определении типа
```haskell
data Point a = Pt { ptX :: a, ptY :: a }
  deriving Show
```
Типы данных, поля которых снабжены метками, называют записями (records). Метки имееют тип `Point a -> a` и работают точно так же, как и определенные вручную проекции
```bash
GHCi> myPt = Pt 3 2
GHCi> ptX myPt
3
GHCi> ptx myPt
3
```
Имеется возможность инициализировать запись не только в стандартном синтаксисе вызова конструктора, но и через метки полей:
```bash
GHCi> myPt1 = Pt {ptY = 2, ptX = 3}
GHCi> myPt1
Pt {ptX = 3, ptY = 2}
```
Обратите внимание, что порядок полей при инициализации произволен. Можно даже инициализировать не все поля, правда при этом вы получите предупреждение при инициализации и ошибку при попытке доступа к неинициализированному полю
```bash
GHCi> myPt2 = Pt {ptX = 3}
warning: [-Wmissing-fields] Fields of `Pt' not initialised: ptY
GHCi> ptX myPt2
3
GHCi> ptY myPt2
*** Exception: Missing field in record construction ptY
```

Помимо стандартного применения в качестве проекций
```haskell
absP p = sqrt (ptX p ^ 2 + ptY p ^ 2)
```
метки полей имеют еще целый ряд стратегий использования. Можно связать их с переменными в образце, вот версия той же самой функции в этом синтаксисе
```haskell
absP' Pt {ptX = x, ptY = y} = sqrt (x ^ 2 + y ^ 2)
```
Может возникнуть вопрос, а в чем преимущество такой техники по сравнению с использованием стандартных образцов
```haskell
absP'' (Pt x y) = sqrt (x ^ 2 + y ^ 2)
```
Кажется, что `absP'` просто многословная версия `absP''`. Однако если полей десяток, а нам нужен доступ только к паре, то синтаксис меток легко позволяет ограничится этой парой, а обычное сопоставление с образцом потребует восьми подчеркиваний для неиспользуемых аргументов.
С помощью меток полей записи можно «обновлять»; вот как это выглядит синтаксически
```bash
GHCi> myPt3 = Pt {ptX = 7, ptY = 8}
GHCi> myPt3 {ptX = 42}
Pt {ptX = 42, ptY = 8}
```
Ясно, что это неразрушающее обновление: `myPt3 {ptX = 42}` это новая запись, разделяющая с `myPt3` общее поле `ptY`. При этом `myPt3` по-прежнему доступен и неизменен:
```bash
GHCi> myPt3
Pt {ptX = 7, ptY = 8}
```
Метки полей одного типа могут быть общими в нескольких конструкторах данных для типа суммы произведений:
```bash
data Homo = Known { name :: String, male :: Bool }
| Unknown { male :: Bool }
GHCi> john = Known "John" True
GHCi> stranger = Unknown False
GHCi> male john
True
GHCi> male stranger
False
``` 
Однако одинаковые метки полей для разных типов недопустимы, их область видимости — глобальная. Добавив
```haskell
data Bad = Bad { male :: Bool }
```
мы получим ошибку компиляции: `Multiple declarations of ’male’`.
Решение о глобальной видимости меток полей, принятое при разработке языка Haskell, часто подвергается критике. Предлагается ряд расширений, решающих эту проблему, но пока они далеки от общепризнаности









