# 11. Полугруппы и моноиды. Представители класса типов Monoid.

## Полугруппа
Полугруппа — это множество с ассоциативной бинарной операцией над ним.
```haskell
infixr 6 <>
class Semigroup a where
  (<>) :: a -> a -> a
```
Для любой полугруппы должен выполняться закон:
```haskell
(x <> y) <> z ≡ x <> (y <> z)
```
### пример
Список — полугруппа относительно конкатенации **(++)**.
```haskell
instance Semigroup [a] where
  (<>) = (++)
```
### полное определение
```haskell
infixr 6 <>
class Semigroup a where
  (<>) :: a -> a -> a
  
  sconcat :: NonEmpty a -> a
  sconcat (a :| as) = go a as where
    go b (c:cs) = b <> go c cs
    go b [] = b
    
  stimes :: Integral b => b -> a -> a
  stimes = stimesDefault
  
infixr 5 :|
data NonEmpty a = a :| [a]
```
## Моноид
Моноид — это множество с ассоциативной бинарной операцией и нейтральным элементом для этой операции (полугруппа с нейтральным элементом).

```haskell
class Semigroup a => Monoid a where
  mempty :: a
  
  mappend :: a -> a -> a
  mappend = (<>)
  
  mconcat :: [a] -> a
  mconcat = foldr mappend mempty
```
### законы
```haskell
mempty <> x ≡ x
x <> mempty ≡ x
(x `mappend` y) `mappend` z ≡ x `mappend` (y `mappend` z)
```
## пример
Список — моноид относительно конкатенации **(++)**
нейтральный элемент — это пустой список.
```haskell
instance Semigroup [a] where
  (<>) = (++)
  
instance Monoid [a] where
  mempty = []
  mconcat = concat
```
**Bool** моноид дважды (относительно конъюнкции **(&&)** и дизъюнкции **(||)**).
Чтобы реализовать разные интерфейсы для одного типа, упакуем его в обертки **newtype**.
```haskell
newtype All = All { getAll :: Bool }
  deriving (Eq, Ord, Read, Show, Bounded)

instance Semigroup All where
  All x <> All y = All (x && y)
```
```haskell
newtype Any = Any { getAny :: Bool }
  deriving (Eq, Ord, Read, Show, Bounded)

instance Semigroup Any where
  Any x <> Any y = Any (x || y)
```
Для моноида нужен еще **mempty** -- **True** в одном случае и **False** -- в другом.

### пример использования:
```haskell
GHCi> getAny . mconcat . map Any $ [False,False,True]
True
```
**Числа** четырежды моноид, относительно:
* сложения (нейтральный элемент это 0);
```haskell
newtype Sum a = Sum { getSum :: a }
  deriving (Eq, Ord, Read, Show, Bounded, Num)

instance Num a => Semigroup (Sum a) where
  Sum x <> Sum y = Sum (x + y)

instance Num a => Monoid (Sum a) where
  mempty = Sum 0
```
``` haskell
GHCi> Sum 3 <> Sum 2
Sum {getSum = 5}
```
* умножения (нейтральный элемент это 1);
```haskell
newtype Product a = Product { getProduct :: a }
  deriving (Eq, Ord, Read, Show, Bounded, Num)

instance Num a => Semigroup (Product a) where
  (<>) = coerce ((*) :: a -> a -> a) -- Data.Coerce

instance Num a => Monoid (Product a) where
  mempty = Product 1
```
Coerce позволяет приводить один тип к другому, если при компиляции у них одинаковое двоичное представление.\
Нужно подключить ScopedTypeVariables, чтобы в типе (при использовании coerce)
ссылаться на **a** из заголовка instance
### пример
```haskell
GHCi> Product 3 <> Product 2
Product {getProduct = 6}
```
* min (нейтральный элемент это maxbound);
Моноид относительно min формируют не только числа:
```haskell
newtype Min a = Min { getMin :: a }
  deriving (Eq, Ord, Read, Show, Bounded)

instance Ord a => Semigroup (Min a) where
  (<>) = coerce (min :: a -> a -> a)
  stimes = stimesIdempotent

instance (Ord a, Bounded a) => Monoid (Min a) where
  mempty = maxBound
```

```haskell
GHCi> Min "Hello" <> Min "Hi"
Min {getMin = "Hello"}

GHCi> mempty :: Min Int
Min {getMin = 9223372036854775807}
```
* max (нейтральный элемент это minbound).






















